/*---Class creates a tube around the path of a Koch snowflake generated by a KochSnowflake instance--------------------------------------------------*/

#ifndef _TUBE_H
#define _TUBE_H

#include <gl\glew.h>
#include "kochSnowflake.h"

#include <glm\glm.hpp>
#include <glm\gtc\matrix_transform.hpp>
#include <glm\gtc\type_ptr.hpp>
#include <glm\gtc\matrix_inverse.hpp>
#include <glm\gtx\vector_angle.hpp>

#include <vector>
#include <random>

class Shader;

class Tube
{
private:

	unsigned int m_vaoID;		     // vertex array object
	unsigned int m_vboID[2];		 // two VBOs - used for colours and vertex data
	GLuint ibo;                      //identifier for the triangle indices

	std::vector<glm::vec3> cols;	 // color values 
	std::vector<glm::vec3> normal;   //vertex normals
	int first = 0;
	int Radius;
	float base;

public:

	KochSnowflake flake;			 // koch snowflake 

	float const Pi = 3.14159265359f;
	//convertion from degree to radians
	float deg2rad = Pi / 180.0f;
	//convertion from radians to degrees
	float rad2deg = 180.0f / Pi;

	std::vector<unsigned int> tris;				//triangles
	std::vector<glm::vec3> verts;				//vertexes
	std::vector<glm::vec3> triangles;			//triangles vertexes
	std::vector<glm::vec3> norms;				//triangles normals
	std::vector<std::vector<unsigned int>> trianglesInBoxe;
	std::vector<std::vector<glm::vec3>> boundingBoxes;

	Tube();
	void render();
	void createBuffers(Shader* myShader);

	// constructs the geometry for the fractal tube
	void constructGeometry(float radiusOfSegments, unsigned int edgeLength, unsigned int dimension, unsigned int numberOfVertexesOfOneSegment);

	// adds a segment from which the tube consists. 
	void addSegment(float radiusOfASegment, const glm::vec3& centerOfASegment, float angle, const glm::vec3& axisOfRotation, unsigned int numberOfVertexes);
	
	// finds an absolute angle ABC, when 3 points A, B and C are given
	float getAngle(const glm::vec3& a, const glm::vec3& b, const glm::vec3& c);
	
	// gets an angle for rotating the newly positioned segments. Parameters are the 3 points of the angle ABC. The segment is 
	// positioned on the point B.
	float getAngleForSegmentPositioning(const glm::vec3& a, const glm::vec3& b, const glm::vec3& c);

	void Tube::getTriangleVerts(unsigned int numberOfVertexesOfOneSegment);
	void Tube::getTriangleNormals(unsigned int numberOfVertexesOfOneSegment);
	bool Tube::collisionBetweenPoint(glm::vec3& v, float threshold, int BBlimitF, int BBlimitL);
	std::vector<unsigned int> Tube::triaglesToCheck(glm::vec3& point, int BBlimitF, int BBlimitL);
	bool Tube::BarycentricCalculation(glm::vec3& point, float dist, int i);

	void Tube::calcBoundingBoxs(unsigned int numberOfVertexesOfOneSegment);
	void Tube::getTriangleSets(unsigned int numberOfVertexesOfOneSegment);

	void Tube::playerPosition(glm::vec3& position, glm::vec3& direction, glm::mat4& directionMat, glm::mat4& turnMat, float speed, float Zturn);

	void Tube::obstaclePositions(float partLength, std::vector<glm::vec3>& obstaclePoints, std::vector<glm::vec3>& obstacleDirections, std::vector<float>& obstacleRotationS);
};

#endif _TUBE_H